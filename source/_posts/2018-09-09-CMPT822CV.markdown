---
layout:     post
title:      "CMPT822(7XX)-Computer Vision"
tags:
    - SFUcourse
---

> “Prof. Yasutaka Furukawa teaches this course”

## 前言

这个老师的经历很传奇，本科东京大学，PhD UIUC，postdoc University of Washington，还去Google，Facebook工作过，也在WUSTL当过助理教授（眼花缭乱）

**本篇所有图片版权所有，严禁转载或使用**

---

## Image filtering

主要有两个方面的内容，point processing 和 filtering。point processing 的处理对象为图像中的单个点，filtering 的处理对象为图像中的一块，会使用到kernel。

1. Point Processing

图像中的每个点，都有RGB三个通道，每个通道的值均在0-255之间，使用MATLAB读取图像的数据格式为 `uint8`，可以保证值不会越界。

---

| 原图                                            | darken 调暗                                       | lower contrast 低对比                                    | non-linear lower contrast                                   |
| ----------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------- | ----------------------------------------------------------- |
| $I$                                             | $I-128$                                           | $I/2$                                                    | $(I / 255) ^{1/3} * 255$                                    |
| ![Pic](/images/in-post/post-blog-asterorig.jpg) | ![Pic](/images/in-post/post-blog-asterdarken.jpg) | ![Pic](/images/in-post/post-blog-asterlowercontrast.jpg) | ![Pic](/images/in-post/post-blog-asternonllwercontrast.jpg) |
---

| invert 反转                                       | lighten 调亮                                     | raise contrast 增对比                                    | non-linear raise contrast                                    |
| ------------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| $255-I$                                           | $I+128$                                          | $I*2$                                                    | $(I / 255) ^2 * 255$                                         |
| ![Pic](/images/in-post/post-blog-asterinvert.jpg) | ![Pic](/images/in-post/post-blog-asterlight.jpg) | ![Pic](/images/in-post/post-blog-asterraisecontrast.jpg) | ![Pic](/images/in-post/post-blog-asternonlraisecontrast.jpg) |

---

MATLAB

```matlab
I = imread('orig.jpg')
Darken = I - 128; %imshow(Darken)
Lower_contrast = I / 2; %imshow(Lower_contrast) 
Non-linear_lower_contrast = uint8((double(I)/255).^(1/3) * 255);
Invert = 255 - I;
Lighten = I + 128;
Raise_contrast = I * 2;
Non-linear_raise_contrast = uint8((double(I)/255).^2 * 255);
```

2. Filtering 

+ Box filter，也叫 2D rect filter，具有blur的效果

![img](/images/in-post/post-blog-boxfilter.png)

+ Gaussian filter 权重满足高斯分布，也具有blur的效果

![img](/images/in-post/post-blog-gaussfilter.png)

效果

| Box filter                                     |
| ---------------------------------------------- |
| ![Pic](/images/in-post/post-blog-asterbox.jpg) |

| Gaussian filter                                  |
| ------------------------------------------------ |
| ![Pic](/images/in-post/post-blog-astergauss.jpg) |

图示效果可能不是很明显，一般来讲，Gaussian filter的效果要更平滑一些，应用的比较多。

MATLAB

```matlab
function [out] = filter(image)
%FILTER
%    Uses the box and gauss filter
%    input: image - 3d array of RGB - pixels containing image
%    output: edges - 3d array of RGB - pixels filter operator values

image = double(image);
box = [ 1, 1, 1;
        1, 1, 1;
        1, 1, 1];
box = box * (1/9);

gauss = [ 1, 2, 1;
          2, 4, 2;
          1, 2, 1];
gauss = gauss * (1/16);

height = size(image,1);
width = size(image,2);
channel = size(image,3);

for i = 2:height - 1
    for j = 2:width - 1
        for k = 1:channel
            mag = 0;
            for a = 1:3
                for b = 1:3
                    mag = mag + (gauss(a, b) * image(i + a - 2, j + b - 2, k));
                    %mag = mag + (box(a, b) * image(i + a - 2, j + b - 2, k));
                end;
            end;     
            edges(i,j,k) = mag;
        end;
    end;
end;
```

+ Sharpening 锐化

![img](/images/in-post/post-blog-sharpening.png)

| 效果                                                  |
| ----------------------------------------------------- |
| ![Pic](/images/in-post/post-blog-astersharpening.jpg) |

+ Sobel filter 边缘检测

Sobel filter可以看做一个1D高斯核与一个1D求导核相乘

![img](/images/in-post/post-blog-Sobelfilter.png)

| Horizontal Sober filter 抽取竖直边界                         | Vertical Sobel filter 抽取水平边界                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![Pic](/images/in-post/post-blog-asterHorizontalSoberfilter.jpg) | ![Pic](/images/in-post/post-blog-asterVerticalSobelfilter.jpg) |

将两个边界融合就可以得到所有边界

![img](/images/in-post/post-blog-asterSobelfilter.jpg)

另一个例子

| Horizontal Sober filter                                      | Vertical Sobel filter                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![Pic](/images/in-post/post-blog-louHorizontalSoberfilter.jpg) | ![Pic](/images/in-post/post-blog-louVerticalSoberfilter.jpg) |

![img](/images/in-post/post-blog-louSobelfilter.jpg)

MATLAB

```matlab
clear all;
clc;

image = imread('test.jpg', 'jpg');
edges = sobel(image);
edges = uint8(edges);
imshowpair(image,edges,'montage')
```



```matlab
function [edges] = sobel(image)
%SOBEL
%    Uses the sobel operator method for edge detection.
%    input: image - 3d array of RGB - pixels containing image
%    output: edges - 3d array of RGB - pixels sobel operator values

image = double(image);

kernelx = [ -1, 0, 1;
            -2, 0, 2;
            -1, 0, 1];


kernely = [  1,  2,  1;
             0,  0,  0;
            -1, -2, -1];

height = size(image,1);
width = size(image,2);
channel = size(image,3);

for i = 2:height - 1
    for j = 2:width - 1
        for k = 1:channel
            magx = 0;
            magy = 0;
            for a = 1:3
                for b = 1:3
                    magx = magx + (kernelx(a, b) * image(i + a - 2, j + b - 2, k));
                    magy = magy + (kernely(a, b) * image(i + a - 2, j + b - 2, k));
                end;
            end;     
            edges(i,j,k) = sqrt(magx^2 + magy^2);
            %edges(i,j,k) = magy;
        end;
    end;
end;
```

+ Laplacian of Gaussian

将Sobel filter中的1D derivative filter 换成 1D Laplace filter 就是LoG，Sobel filter 可以理解为 Derivative of Gaussian。

![img](/images/in-post/post-blog-LaplacianofGaussian.png)

Laplacian of Gaussian (左) vs Derivative of Gaussian (右)

![img](/images/in-post/post-blog-LapofGaussianvsDevofGaussian.jpg)

LoG在边界处有zero-crossing，也就是边界本事比周围暗，而DoG在边界处有peak，也就是边界本身很粗很亮，所以LoG定位边界更准确。/Zero crossings are more accurate at localizing edges (but not very convenient)/